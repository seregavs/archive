class ZCLMK_IOBJNM definition
  public
  final
  create public .

public section.

  methods CONSTRUCTOR
    importing
      !I_ZMKRUN type ZMKRUN
      !I_ZMKCONFIG type ZMKCONFIG
      !I_IOBJNM type RSCHABASNM
      !I_ZMKOBJTYPE type ZMKOBJTYPE
      !I_LOG_PROTOCOL type BALOGNR .
  methods MASK_ADSO_LIST .
  methods GET_IOBJNM
    returning
      value(O_IOBJNM) type RSCHABASNM .
protected section.
private section.

  data IOBJNM type RSCHABASNM .
  data IS_KEYGEN type CHAR1 .
  data LANGU type LANGU .
  data LOG_HANDLE type BALLOGHNDL .
  data LOG_PROTOCOL type BALOGNR .
  data PREFIX_KEY type CHAR1 .
  data PREFIX_TEXT type CHAR20 .
  data REF_IOBJNM type RSCHABASNM .
  data REF_IOBJNM_TBL type ZMKKEYVAL_TBL .
  data ZMKCONFIG type ZMKCONFIG .
  data ZMKOBJTYPE type ZMKOBJTYPE .
  data ZMKREFOBJTYPE type ZMKOBJTYPE .
  data ZMKRUN type ZMKRUN .
  data ZMKTYPE type ZMKTYPE .
  data INT2CNT type INTEGER2 .

  methods MASK_ADSO
    importing
      !I_AODSO type RSDODSOBJECT
      !I_TARGET type ZMKTARGET .
  methods FILL_ZMKKEYM
    importing
      !I_KEY_ORIG type ZMKKEYTYPE
      !I_KEY_INDEX type INTEGER2 .
  methods UPDATE_ADSO_TBL
    importing
      !I_ADSO_TBL type CATSTNAM .
  methods MARE_REF_IOBJNM_TBL .
ENDCLASS.



CLASS ZCLMK_IOBJNM IMPLEMENTATION.


  METHOD constructor.
    me->iobjnm = i_iobjnm.
    me->zmkconfig = i_zmkconfig.
    me->zmkrun = i_zmkrun.
    me->zmkobjtype = i_zmkobjtype.
    me->log_protocol = i_log_protocol.
    int2cnt = 1.
    IF me->log_protocol IS NOT INITIAL.
      me->log_handle = cl_log_ppf=>load_log( me->log_protocol ).
    ENDIF.

    SELECT SINGLE * FROM zmkiobjmn INTO @DATA(ls_iobjn)
     WHERE iobjmn = @me->iobjnm
       AND zmkconfig = @me->zmkconfig
       AND zmkobjtype = @me->zmkobjtype.
    IF sy-subrc = 0.
      me->langu = ls_iobjn-langu.
      me->is_keygen = ls_iobjn-is_keygen.
      me->prefix_key = ls_iobjn-prefix_key.
      me->prefix_text = ls_iobjn-prefix_text.
      me->zmktype = ls_iobjn-zmktype.
      me->ref_iobjnm = ls_iobjn-ref_iobjmn.
      me->zmkrefobjtype = ls_iobjn-zmkrefobjtype.
    ENDIF.
    IF me->iobjnm = 'WR020FZZZ'.
      DATA(lv_i) = 0.
    ENDIF.
    IF me->ref_iobjnm IS NOT INITIAL.
      me->mare_ref_iobjnm_tbl( ).
    ENDIF.
  ENDMETHOD.


  METHOD fill_zmkkeym.
    DATA:
      lo_conn         TYPE REF TO cl_sql_connection,
      lo_statement    TYPE REF TO cl_sql_statement,
      lx_sql          TYPE REF TO cx_sql_exception,
      lv_key_orig     TYPE zmkkeytype,
      lv_n6(6)        TYPE n,
      lv_key_index(5) TYPE n,
      lv_keymask(20)  TYPE c.

    lv_key_index = i_key_index.
    IF  me->ref_iobjnm IS INITIAL. " no referemce table
      IF me->zmkobjtype = 'F'. " field
        CASE me->iobjnm.
          WHEN 'ZBUACIATA'.
            IF i_key_orig = 'RU'.
              lv_keymask = 'SR'.
            ELSE.
              lv_keymask = |{ me->prefix_key }{ lv_key_index }|.
            ENDIF.
          WHEN OTHERS.
            lv_keymask = |{ me->prefix_key }{ lv_key_index }|.
        ENDCASE.
      ENDIF.
    ELSE. " has reference table
      TRY.
          IF me->zmkobjtype = 'F'. " field
            CASE me->iobjnm.
              WHEN 'ZBUFLINUM' OR 'ZBUFLNAR' OR 'ZBUFLNDP' OR 'WR020FZZZ'. lv_key_orig = i_key_orig+1(5). "search for shorter value (without leading 0).
              " all fields above are 6 characters
              WHEN 'WR120FZZZ'. " text for airline code. take orig code from orig text by addiing leadings 0s.
                lv_n6 = i_key_orig.
                lv_key_orig = lv_n6.
              WHEN OTHERS. lv_key_orig = i_key_orig.
            ENDCASE.
          ELSEIF me->zmkobjtype = 'O'. " infoobject
            CASE me->iobjnm.
              WHEN 'ZBUFLINUM'. lv_key_orig = i_key_orig+1(5). "search for shorter value (without leading 0)
              " all iobjs above are 6 characters
              WHEN OTHERS. lv_key_orig = i_key_orig.
            ENDCASE.
          ENDIF.
          lv_keymask = me->ref_iobjnm_tbl[ key_orig = lv_key_orig ]-key_mask.
        CATCH cx_sy_itab_line_not_found.
          lv_keymask = |{ me->prefix_key }{ lv_key_index }|.
          DATA(lv_sql_ref) =
             |INSERT INTO "ZMKKEYM"(IOBJMN, KEY_ORIG, ZMKOBJTYPE, KEY_MASK) VALUES( '{ me->ref_iobjnm }', '{ i_key_orig }','{ me->zmkrefobjtype }','{ lv_keymask }')|.
      ENDTRY.
    ENDIF.
    IF lv_keymask = '500607'.
      DATA(lv_i) = 1.
    ENDIF.
    DATA(lv_sql) =
       |INSERT INTO "ZMKKEYM"(IOBJMN, KEY_ORIG, ZMKOBJTYPE, KEY_MASK) VALUES( '{ me->iobjnm }', '{ i_key_orig }','{ me->zmkobjtype }','{ lv_keymask }')|.
    TRY.
        lo_conn = cl_sql_connection=>get_connection( ).
        lo_statement = lo_conn->create_statement( ).
        DATA(l_row_cnt) = lo_statement->execute_update( lv_sql ).
        IF lv_sql_ref IS NOT INITIAL.
          l_row_cnt = lo_statement->execute_update( lv_sql_ref ).
        ENDIF.
      CATCH cx_sql_exception INTO lx_sql.
    ENDTRY.
  ENDMETHOD.


  METHOD get_iobjnm.
    CASE me->zmkobjtype.
      WHEN 'F'. o_iobjnm = me->iobjnm.
      WHEN 'O'.
        DATA(lv_c) = me->iobjnm+0(1).
        CASE lv_c.
          WHEN '0'. o_iobjnm = me->iobjnm+1(20).
          WHEN OTHERS. o_iobjnm = |/BIC/{ me->iobjnm }|.
        ENDCASE.
      WHEN OTHERS. RETURN.
    ENDCASE.
  ENDMETHOD.


  METHOD mare_ref_iobjnm_tbl.
    CLEAR: me->ref_iobjnm_tbl.
    SELECT key_orig, key_mask INTO TABLE @me->ref_iobjnm_tbl
      FROM zmkkeym
     WHERE iobjmn = @me->ref_iobjnm
       AND zmkobjtype = @me->zmkrefobjtype
     ORDER BY key_orig.
  ENDMETHOD.


  METHOD mask_adso.
    DATA: lt_adsotable TYPE STANDARD TABLE OF string,
          lo_conn      TYPE REF TO cl_sql_connection,
          lo_statement TYPE REF TO cl_sql_statement,
          lx_sql       TYPE REF TO cx_sql_exception,
          lt_res       TYPE REF TO data,
          lt_res2      TYPE zmkname_tbl,
          lv_adso_tbl  TYPE catstnam,
          dummy        TYPE c.

    CASE i_target.
      WHEN 1.  APPEND |/BIC/A{ i_aodso }1| TO lt_adsotable.
      WHEN 2.  APPEND |/BIC/A{ i_aodso }2| TO lt_adsotable.
      WHEN 4.  APPEND |/BIC/A{ i_aodso }1| TO lt_adsotable. APPEND |/BIC/A{ i_aodso }2| TO lt_adsotable.
    ENDCASE.
    IF lines( lt_adsotable ) = 0.
      RETURN.
    ENDIF.

    MESSAGE i002(zmk) WITH me->get_iobjnm( ) i_aodso INTO dummy.
    CALL METHOD cl_log_ppf=>add_message( ip_problemclass = '4' ip_handle = me->log_handle ).

    LOOP AT lt_adsotable ASSIGNING FIELD-SYMBOL(<fs_adsotable>).
      DATA(lv_sql) =
         |SELECT DISTINCT "{ me->get_iobjnm( ) }" as MKVALUE FROM "{ <fs_adsotable> }" WHERE "{ me->get_iobjnm( ) }" <> ''|.
      TRY.
          GET REFERENCE OF lt_res2 INTO lt_res.
          lo_conn = cl_sql_connection=>get_connection( ).
          lo_statement = lo_conn->create_statement( ).
          DATA(l_res_ref) = lo_statement->execute_query( lv_sql ).
          l_res_ref->set_param_table( lt_res ).
          l_res_ref->next_package( ).
          l_res_ref->close( ).
          IF lt_res2 IS NOT INITIAL.
            IF me->zmktype = 1. " change texts
            ENDIF.
            IF me->zmktype = 2. " create mask keys and substitute
              IF me->is_keygen = 'X'. " need to generate keys
                MESSAGE i003(zmk) WITH me->get_iobjnm( ) INTO dummy.
                CALL METHOD cl_log_ppf=>add_message( ip_problemclass = '4' ip_handle = me->log_handle ).
                LOOP AT lt_res2 ASSIGNING FIELD-SYMBOL(<fs_res2>).
                  me->fill_zmkkeym( i_key_orig = <fs_res2>-mkvalue i_key_index = me->int2cnt ). " generate mask key for every unique key_orig
                  me->int2cnt = me->int2cnt + 1.
                ENDLOOP.
              ENDIF.
              lv_adso_tbl = <fs_adsotable>.
              me->update_adso_tbl( i_adso_tbl = lv_adso_tbl  ).
            ENDIF.
          ENDIF.
        CATCH cx_sql_exception INTO lx_sql.
      ENDTRY.
    ENDLOOP.

    MESSAGE i005(zmk) WITH me->get_iobjnm( ) i_aodso INTO dummy.
    CALL METHOD cl_log_ppf=>add_message( ip_problemclass = '4' ip_handle = me->log_handle ).

  ENDMETHOD.


  METHOD mask_adso_list.
    SELECT * FROM zmkbinding INTO TABLE @DATA(lt_binding)
     WHERE zmkconfig = @me->zmkconfig
       AND zmkobjtype = @me->zmkobjtype
       AND iobjmn = @me->iobjnm
       AND is_active = 'X'.
    IF sy-subrc NE 0.
      RETURN.
    ENDIF.
    LOOP AT lt_binding ASSIGNING FIELD-SYMBOL(<fs_binding>).
      me->mask_adso( i_aodso = <fs_binding>-aodso i_target = <fs_binding>-target ).
    ENDLOOP.
  ENDMETHOD.


  METHOD update_adso_tbl.
    DATA:
      lo_conn      TYPE REF TO cl_sql_connection,
      lo_statement TYPE REF TO cl_sql_statement,
      lx_sql       TYPE REF TO cx_sql_exception,
      dummy        TYPE c.

    SELECT * FROM zmkkeym INTO TABLE @DATA(lt_zmkkeym)
      WHERE iobjmn = @me->iobjnm
        AND zmkobjtype = @me->zmkobjtype.
    IF sy-dbcnt > 0.

      MESSAGE i004(zmk) WITH me->get_iobjnm( ) i_adso_tbl INTO dummy.
      CALL METHOD cl_log_ppf=>add_message( ip_problemclass = '4' ip_handle = me->log_handle ).

      LOOP AT lt_zmkkeym ASSIGNING FIELD-SYMBOL(<fs_zmkkeym>).
        DATA(lv_sql) =
           |UPDATE "{ i_adso_tbl }" SET "{ me->get_iobjnm( ) }" = '{ <fs_zmkkeym>-key_mask }' WHERE "{ me->get_iobjnm( ) }" = '{ <fs_zmkkeym>-key_orig }' |.
        TRY.
            lo_conn = cl_sql_connection=>get_connection( ).
            lo_statement = lo_conn->create_statement( ).
            DATA(l_row_cnt) = lo_statement->execute_update( lv_sql ).

          CATCH cx_sql_exception INTO lx_sql.
        ENDTRY.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
